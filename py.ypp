import pandas as pd
from lxml import etree

def strip_namespaces(xml_string):
    """Remove namespaces from the XML string."""
    parser = etree.XMLParser(ns_clean=True, recover=True, encoding='utf-8')
    tree = etree.fromstring(xml_string.encode('utf-8'), parser=parser)
    for elem in tree.iter():
        if elem.tag.startswith('{'):
            elem.tag = elem.tag.split('}', 1)[1]  # Strip namespace
    return tree

def extract_trade_data(node):
    """Extract tradeId and its related data."""
    trade_data = {}
    
    if node.tag == 'tradeHeader':
        for child in node:
            if child.tag == 'tradeId':
                trade_data['tradeId'] = child.text.strip() if child.text else ''
                for attr_name, attr_value in child.attrib.items():
                    trade_data[f'tradeId_{attr_name}'] = attr_value

            elif child.tag == 'alternateId':
                trade_data['alternateId'] = child.text.strip() if child.text else ''
                for attr_name, attr_value in child.attrib.items():
                    trade_data[f'alternateId_{attr_name}'] = attr_value
    
    return trade_data

def extract_swap_data(root):
    """Extract swapStream and its streamIndex."""
    swap_data = {}

    swap_stream_nodes = root.xpath('.//swapStream')
    for swap_stream in swap_stream_nodes:
        if 'streamIndex' in swap_stream.attrib:
            swap_data['swapStream_index'] = swap_stream.attrib['streamIndex']
            for child in swap_stream:
                if child.tag == 'payOrReceive':
                    swap_data['payOrReceive'] = child.text.strip() if child.text else ''

    return swap_data

def extract_additional_data(root, xpath):
    """Extract additional data based on the provided XPath."""
    additional_data = {}
    additional_nodes = root.xpath(xpath)
    for node in additional_nodes:
        # For demonstration purposes, let's just extract all text data from the node
        additional_data[node.tag] = node.text.strip() if node.text else ''
        for attr_name, attr_value in node.attrib.items():
            additional_data[f"{node.tag}_{attr_name}"] = attr_value
    return additional_data

def extract_data(xml_string, additional_xpath=None):
    """Extract node data from the XML string."""
    try:
        # Parse XML and remove namespaces
        root = strip_namespaces(xml_string)

        # Prepare the data dictionary
        data = {}

        # Extract default data using the default_xpath
        default_node = root.xpath('.//tradeHeader')
        if default_node:
            trade_data = extract_trade_data(default_node[0])
            data.update(trade_data)

        # Extract swapStream-related data
        swap_data = extract_swap_data(root)
        data.update(swap_data)

        # If an additional XPath is provided, extract that data
        if additional_xpath:
            additional_data = extract_additional_data(root, additional_xpath)
            data.update(additional_data)

        return data

    except Exception as e:
        print(f"Error processing XML: {e}")
        return {}

def main():
    # Path to the CSV file containing XML data
    csv_file_path = "bcml_data.csv"  # Change to your actual CSV file path
    # Column in the CSV file that contains the XML strings
    xml_column = 'bcml'  # Change this to the name of your XML column
    # Example additional XPath to use; set to None for default behavior
    additional_xpath = './/swapStream'  # Change this as needed or keep it None

    # Read the CSV file
    df = pd.read_csv(csv_file_path)

    # List to store all extracted data from the entire file
    all_extracted_data = []

    # Process each row and extract data
    for index, row in df.iterrows():
        xml_string = row[xml_column]
        extracted_values = extract_data(xml_string, additional_xpath)

        # Add the row index for reference
        extracted_values['row_index'] = index

        # Append extracted values to the main list
        all_extracted_data.append(extracted_values)

    # Convert extracted data into a DataFrame
    if all_extracted_data:
        results_df = pd.DataFrame(all_extracted_data)
    else:
        results_df = pd.DataFrame(columns=["No Data Found"])

    # Output the results to a CSV file
    output_file = "extracted_values_output.csv"
    results_df.to_csv(output_file, index=False)
    print(f"Extracted data saved to {output_file}")

if __name__ == "__main__":
    main()
