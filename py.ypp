import pandas as pd
from lxml import etree

def strip_namespaces(xml_string):
    """Remove namespaces from the XML string."""
    parser = etree.XMLParser(ns_clean=True, recover=True, encoding='utf-8')
    tree = etree.fromstring(xml_string.encode('utf-8'), parser=parser)
    for elem in tree.iter():
        if elem.tag.startswith('{'):
            elem.tag = elem.tag.split('}', 1)[1]  # Strip namespace
    return tree

def extract_node_data(node):
    """Extracts text and attributes from a node."""
    extracted_data = {}

    # Extract node's text (if any) and attributes
    if node.text and node.text.strip():
        extracted_data[node.tag] = node.text.strip()

    # Extract attributes like type, version, etc.
    for attr_name, attr_value in node.attrib.items():
        extracted_data[f"{node.tag}_{attr_name}"] = attr_value

    return extracted_data

def extract_related_nodes(node):
    """Extracts data from related sibling nodes under the same parent."""
    related_data = {}
    
    # Get the parent node of the target node
    parent = node.getparent()
    
    if parent is not None:
        # Collect data from all child nodes of the parent, i.e., siblings of the original node
        for sibling in parent:
            sibling_data = extract_node_data(sibling)
            related_data.update(sibling_data)
    
    return related_data

def extract_data(xml_string, xpath):
    """Extract node data dynamically based on the provided XPath and include related nodes."""
    try:
        # Parse XML and remove namespaces
        root = strip_namespaces(xml_string)

        # Find the nodes based on the provided XPath
        nodes = root.xpath(xpath)

        # List to store extracted data
        extracted_data_list = []

        # Iterate over the matching nodes to extract their data and related nodes
        for node in nodes:
            data = extract_node_data(node)

            # Extract related sibling nodes under the same parent
            related_data = extract_related_nodes(node)
            data.update(related_data)  # Include related nodes' data

            extracted_data_list.append(data)

        return extracted_data_list

    except Exception as e:
        print(f"Error processing XML: {e}")
        return []

def main():
    # Path to the CSV file containing XML data
    csv_file_path = "bcml_data.csv"  # Change to your actual CSV file path
    # Column in the CSV file that contains the XML strings
    xml_column = 'bcml'  # Change this to the name of your XML column
    # Dynamic XPath provided by the user
    xpath = input("Enter the XPath to extract (e.g., .//tradeHeader/tradeId): ")

    # Read the CSV file
    df = pd.read_csv(csv_file_path)

    # List to store all extracted data from the entire file
    all_extracted_data = []

    # Process each row and extract data based on the provided XPath
    for index, row in df.iterrows():
        xml_string = row[xml_column]
        extracted_values = extract_data(xml_string, xpath)

        # Add the row index for reference
        for value in extracted_values:
            value['row_index'] = index

        # Append extracted values to the main list
        all_extracted_data.extend(extracted_values)

    # Convert extracted data into a DataFrame
    if all_extracted_data:
        results_df = pd.DataFrame(all_extracted_data)
    else:
        results_df = pd.DataFrame(columns=["No Data Found"])

    # Output the results to a CSV file
    output_file = "extracted_values_output.csv"
    results_df.to_csv(output_file, index=False)
    print(f"Extracted data saved to {output_file}")

if __name__ == "__main__":
    main()
