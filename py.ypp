import pandas as pd
from lxml import etree

def strip_namespaces(xml_string):
    """Remove namespaces from the XML string."""
    parser = etree.XMLParser(ns_clean=True, recover=True, encoding='utf-8')
    tree = etree.fromstring(xml_string.encode('utf-8'), parser=parser)
    for elem in tree.iter():
        if elem.tag.startswith('{'):
            elem.tag = elem.tag.split('}', 1)[1]  # Strip namespace
    return tree

def extract_sibling_data(node):
    """Extract all sibling nodes and their attributes."""
    sibling_data = {}

    # Extract the node itself (its text and attributes)
    if node.text and node.text.strip():
        sibling_data[node.tag] = node.text.strip()

    # Extract the attributes of the node
    for attr_name, attr_value in node.attrib.items():
        sibling_data[f"{node.tag}_{attr_name}"] = attr_value

    # Extract siblings (other child nodes under the same parent)
    parent = node.getparent()
    if parent is not None:
        for sibling in parent:
            if sibling != node:  # Avoid extracting the current node twice
                if sibling.text and sibling.text.strip():
                    sibling_data[sibling.tag] = sibling.text.strip()

                # Extract attributes for sibling nodes
                for attr_name, attr_value in sibling.attrib.items():
                    sibling_data[f"{sibling.tag}_{attr_name}"] = attr_value

    return sibling_data

def extract_data(xml_string, xpath):
    """Extract all attributes and sibling values based on the given XPath."""
    try:
        # Parse XML and remove namespaces
        root = strip_namespaces(xml_string)

        # Find the nodes based on the provided XPath
        nodes = root.xpath(xpath)

        # List to store extracted data
        extracted_data = []

        # Iterate over nodes to extract all related data
        for node in nodes:
            data = extract_sibling_data(node)
            extracted_data.append(data)

        return extracted_data

    except Exception as e:
        print(f"Error processing XML: {e}")
        return []

def main():
    # Path to the CSV file containing XML data
    csv_file_path = "bcml_data.csv"  # Change to your actual CSV file path
    # Column in the CSV file that contains the XML strings
    xml_column = 'bcml'  # Change this to the name of your XML column
    # Dynamic XPath provided by the user
    xpath = input("Enter the XPath to extract: ")  # e.g., ".//trade/tradeHeader/tradeId"

    # Read the CSV file
    df = pd.read_csv(csv_file_path)

    # List to store all extracted data from the entire file
    all_extracted_data = []

    # Process each row and extract data based on the provided XPath
    for index, row in df.iterrows():
        xml_string = row[xml_column]
        extracted_values = extract_data(xml_string, xpath)

        # Add additional context like row index for reference (optional)
        for value in extracted_values:
            value['row_index'] = index

        # Append extracted values to the main list
        all_extracted_data.extend(extracted_values)

    # Convert extracted data into a DataFrame
    if all_extracted_data:
        results_df = pd.DataFrame(all_extracted_data)
    else:
        results_df = pd.DataFrame(columns=["No Data Found"])

    # Output the results to a CSV file
    output_file = "extracted_values_output.csv"
    results_df.to_csv(output_file, index=False)
    print(f"Extracted data saved to {output_file}")

if __name__ == "__main__":
    main()
