import pandas as pd
from lxml import etree

def strip_namespaces(xml_string):
    """Remove namespaces from the XML string."""
    parser = etree.XMLParser(ns_clean=True, recover=True, encoding='utf-8')
    tree = etree.fromstring(xml_string.encode('utf-8'), parser=parser)
    for elem in tree.iter():
        if elem.tag.startswith('{'):
            elem.tag = elem.tag.split('}', 1)[1]  # Strip namespace
    return tree

def extract_node_data(node):
    """Extracts text and attributes from a node."""
    extracted_data = {}

    # Extract node's text (if any) and attributes
    if node.text and node.text.strip():
        extracted_data[node.tag] = node.text.strip()

    # Extract attributes like type, version, etc.
    for attr_name, attr_value in node.attrib.items():
        extracted_data[f"{node.tag}_{attr_name}"] = attr_value

    return extracted_data

def extract_data(xml_string, custom_xpath=None):
    """Extract node data dynamically based on default and custom XPath."""
    try:
        # Parse XML and remove namespaces
        root = strip_namespaces(xml_string)

        # Default XPath to extract tradeHeader and related information
        default_xpath = './/tradeHeader'
        row_data = {}

        # Extract tradeHeader-related data
        default_nodes = root.xpath(default_xpath)
        if default_nodes:
            for node in default_nodes:
                # Extracting main components from tradeHeader
                trade_id = node.xpath('./tradeId/text()')
                trade_id_type = node.xpath('./tradeIdType/text()')
                alternate_trade_id = node.xpath('./alternateTradeId/text()')
                alternate_trade_id_type = node.xpath('./alternateTradeIdType/text()')
                trade_id_version = node.xpath('./tradeIdVersion/text()')
                alternate_id_version = node.xpath('./alternateIdVersion/text()')

                # Update row_data with the extracted values (handle cases where they may not exist)
                row_data['tradeId'] = trade_id[0] if trade_id else None
                row_data['tradeIdType'] = trade_id_type[0] if trade_id_type else None
                row_data['alternateTradeId'] = alternate_trade_id[0] if alternate_trade_id else None
                row_data['alternateTradeIdType'] = alternate_trade_id_type[0] if alternate_trade_id_type else None
                row_data['tradeIdVersion'] = trade_id_version[0] if trade_id_version else None
                row_data['alternateIdVersion'] = alternate_id_version[0] if alternate_id_version else None

                # Extract children of tradeHeader (if any)
                for child in node:
                    child_data = extract_node_data(child)
                    row_data.update(child_data)

        # If a custom XPath is provided, extract that data too
        if custom_xpath:
            custom_nodes = root.xpath(custom_xpath)
            if custom_nodes:
                for node in custom_nodes:
                    custom_data = extract_node_data(node)

                    # Extract any children of the custom node
                    for child in node:
                        custom_child_data = extract_node_data(child)
                        custom_data.update(custom_child_data)

                    # Merge custom XPath data with tradeHeader data in the same row
                    row_data.update(custom_data)
        # If no custom XPath is provided, ensure default data is included
        elif not custom_xpath and not default_nodes:
            print("Warning: No data found with the default XPath.")

        return row_data

    except Exception as e:
        print(f"Error processing XML: {e}")
        return {}

def main():
    # Path to the CSV file containing XML data
    csv_file_path = "bcml_data.csv"  # Change to your actual CSV file path
    # Column in the CSV file that contains the XML strings
    xml_column = 'bcml'  # Change this to the name of your XML column

    # Input from the user for custom XPath (optional)
    xpath = input("Enter the XPath to extract (leave blank for just default tradeHeader): ").strip()
    # If user input is empty, set custom_xpath to None
    custom_xpath = xpath if xpath else None

    # Read the CSV file
    df = pd.read_csv(csv_file_path)

    # List to store all extracted data from the entire file
    all_extracted_data = []

    for index, row in df.iterrows():
        xml_data = row[xml_column]
        extracted_data = extract_data(xml_data, custom_xpath=custom_xpath)
        all_extracted_data.append(extracted_data)

    # Create a DataFrame from the extracted data
    extracted_df = pd.DataFrame(all_extracted_data)

    # Save the extracted data to a new CSV file
    extracted_df.to_csv('extracted_data.csv', index=False)

if __name__ == "__main__":
    main()
